<!DOCTYPE ui:UiBinder SYSTEM "http://dl.google.com/gwt/DTD/xhtml.ent">
<!--
~ Copyright 2015 Danilo Reinert
~
~ Licensed under the Apache License, Version 2.0 (the "License");
~ you may not use this file except in compliance with the License.
~ You may obtain a copy of the License at
~
~     http://www.apache.org/licenses/LICENSE-2.0
~
~ Unless required by applicable law or agreed to in writing, software
~ distributed under the License is distributed on an "AS IS" BASIS,
~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
~ See the License for the specific language governing permissions and
~ limitations under the License.
-->
<ui:UiBinder xmlns:ui='urn:ui:com.google.gwt.uibinder'
             xmlns:g='urn:import:com.google.gwt.user.client.ui'>
  <g:HTMLPanel>
    <!-- JSON SECTION -->
    <g:HTMLPanel styleName="requestor-showcase-section">
      <h1 class="page-header" id="json-serialization">JSON Serialization</h1>
      <p class="lead">
        Requestor has built-in serialization for JSON.
      </p>

      <div class="requestor-showcase-innersection">
        <h3>Overlays</h3>
        <p>
          Overlay Types are a great feature from GWT to deal with JSON data efficiently.
          They interoperate with native javascript objects with zero overhead.
        </p>

        <p>
          With one configuration you can enable JSON serialization for Overlay Types:
          in you GWT module descriptor set the <code>RequestorInitializer</code> to be <code>RequestorInitializerForJson</code>.
        </p>

        <div class="highlight">
          <pre ui:field="overlaysSetup" class="xml">
            <code>&lt;replace-with class=&quot;io.reinert.requestor.RequestorInitializerForJson&quot;&gt;
              <br/>&#32;&#32;&lt;when-type-is class="io.reinert.requestor.RequestorInitializer"/&gt;
              <br/>&lt;/replace-with&gt;
            </code>
          </pre>
        </div>

        <p>
          Now, your <code>Requestor</code> container is initialized with a serializer and deserializer for JSON-Overlays.
          <br/>
          When you send a request with some overlay type in the payload, it will be serialized with the browser's <code>JSON#stringify</code> method.
          <br/>
          When you ask an overlay type in a request, the response payload will be deserialized using <code>JsonUtils#safeEval</code>.
          You can alternatively use <code>JsonUtils#unsafeEval</code> (faster but not secure) by setting the public flag <code>OverlaySerdes#USE_SAFE_EVAL</code> to false.
        </p>

        <div class="requestor-callout requestor-callout-info">
          <h4>Even faster deserialization</h4>
          <p>
            JSON deserialization to Overlay Types is faster than normal because it only requires the evaluation of the serialized content into a JavaScript object.
            Nevertheless, the deserialization of json arrays is not so fast, because an iteration over all items is necessary to accumulate the result in a collection.
            If you want even faster deserialization, you may consider using the Requestor-TurboGWT extension, which overcome this issue when possible.
            Read more at the <a href="https://github.com/reinert/requestor/wiki/Overlay-Types-Serialization" target="_blank">docs</a>.
          </p>
        </div>
      </div>

      <div class="requestor-showcase-innersection">
        <h3>JavaBean Interfaces</h3>
        <p>
          GWT has a powerful feature to serialize/deserialize JavaBean Interfaces to/from JSON content: the <strong>AutoBean Framework</strong>.
          It can be used both in server and client sides.
        </p>

        <p>
          If you are working with JavaBean interfaces, you can enable AutoBeans auto-serialization for serializing and deserializing your interfaces:
          just import the <code>RequestorWithAutoBean</code> module in your GWT module descriptor.
        </p>

        <div class="highlight">
          <pre ui:field="autobeansSetup" class="xml">
            <code>&lt;inherits name=&quot;io.reinert.requestor.RequestorWithAutoBean&quot;/&gt;
            </code>
          </pre>
        </div>

        <p>
          Now, annotate each JavaBean interface with the <code>@Json</code> annotation (present in <em>requestor-annotations</em> dependency).
          Requestor will handle the serialization of the annotated types using the AutoBean Framework.
          More information can be found at the <a href="https://github.com/reinert/requestor/wiki/JavaBean-Interface-JSON-Serialization" target="_blank">docs</a>.
        </p>

        <div class="requestor-callout requestor-callout-danger">
          <h4>Deserialize arrays only to List or Set</h4>
          <p>
            The AutoBean Framework has a special implementation for deserializing objects efficiently.
            It doesn't deserialize arrays to specific collection types (List or Set implementations like ArrayList or HashSet).
            Thereby, we cannot ask for any concrete collection classes when requesting for collections of objects.
            Use only <code>List.class</code> or <code>Set.class</code> when you intend to retrieve a collection result.
          </p>
        </div>

        <div class="requestor-callout requestor-callout-info">
          <h4>Use Requestor to get instances of the annotated types</h4>
          <p>
            Requestor automatically generates factories for the annotated interfaces.
            So if you need to obtain new instances of these types you can resort to <code>Requestor#getInstance(Class&lt;T&gt;)</code>.
            Alternatively you can get the Provider&lt;T&gt; with <code>Requestor#getProvider(Class&lt;T&gt;)</code> and later get an instance with <code>Provider#get()</code>.
          </p>
        </div>
      </div>

      <div class="requestor-showcase-innersection">
        <h3>POJOs</h3>
        <p>
          It is also possible to enable JSON serialization of Plain Old Java Objects (POJOs).
          Requestor has an extension that integrates the <a href="https://github.com/nmorel/gwt-jackson/" target="_blank">gwt-jackson</a> library to its serialization mechanism: <strong>requestor-gwtjackson</strong>.
          Add this dependency to your project and import the following GWT module:
        </p>

        <div class="highlight">
          <pre ui:field="gwtjacksonSetup" class="xml">
            <code>&lt;inherits name=&quot;io.reinert.requestor.RequestorWithGwtJackson&quot;/&gt;
            </code>
          </pre>
        </div>

        <p>
          Now, annotate each POJO with the <code>@Json</code> annotation (present in <em>requestor-annotations</em> dependency).
          Requestor will handle the serialization of the annotated types using the gwt-jackson library.
          More information can be found at the <a href="https://github.com/reinert/requestor/wiki/POJO-JSON-Serialization" target="_blank">docs</a>.
        </p>

        <div class="requestor-callout requestor-callout-info">
          <h4>Use gwt-jackson's full feature set</h4>
          <p>
            The requestor-gwtjackson extension completely integrates the gwt-jackson library to your project.
            Therefore, you can make full use of all gwt-jackson's features.
          </p>
        </div>
      </div>
    </g:HTMLPanel>

  <!-- CUSTOM SECTION -->
  <g:HTMLPanel styleName="requestor-showcase-section">
    <h1 class="page-header" id="custom-serialization">Custom Serialization</h1>
    <p class="lead">
      Create Serializers and Deserializers for specific classes and media types.
    </p>

    <div class="requestor-showcase-innersection">
      <h3>Serializers</h3>
      <p>
        Serializers are responsible for serializing objects to some media type.
      </p>

      <p>
        To create a serializer you must implement the <code>Serializer</code> interface.
      </p>

      <div class="highlight">
        <pre ui:field="mySerializer" class="java">
          <code>class MySerializer implements Serializer&lt;MyObject&gt; {
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public Class&lt;MyObject&gt; handledType() {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return MyObject.class;
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public String[] mediaType() {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;/* Return an array of media type patterns; wildcards are acceptable */
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return new String[]{"*/xml"};
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public String serialize(MyObject myObject, SerializationContext ctx) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return "&lt;my&gt;&lt;stringField&gt;" + myObject.getStringField() + "&lt;/stringField&gt;"
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+ "&lt;intField&gt;" + myObject.getIntField() + "&lt;/intField&gt;"
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;+ "&lt;dateField&gt;" + myObject.getDateField().getTime() + "&lt;/dateField&gt;&lt;/my&gt;";
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public String serialize(Collection&lt;MyObject&gt; myCollection, SerializationContext ctx) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;StringBuilder sb = new StringBuilder("&lt;array&gt;");
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;for (MyObject myObject : myCollection) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;sb.append(serialize(myObject, ctx));
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return sb.append("&lt;/array&gt;").toString();
            <br/>&#32;&#32;&#32;&#32;}
            <br/>}
          </code>
        </pre>
      </div>

      <p>
        Make your serializer available to Requestor by registering it.
      </p>

      <div class="highlight">
        <pre ui:field="mySerializerReg" class="java">
          <code>requestor.addSerializer(new MySerializer());</code>
        </pre>
      </div>

      <p>
        <em>Note: #addSerializer returns a HandlerRegistration instance which enables you to later cancel the registration.</em>
      </p>
    </div>

    <div class="requestor-showcase-innersection">
      <h3>Deserializers</h3>
      <p>
        Deserializers are responsible for deserializing raw content of some media type to an object.
      </p>

      <p>
        To create a deserializer you must implement the <code>Deserializer</code> interface.
      </p>

      <div class="highlight">
        <pre ui:field="myDeserializer" class="java">
          <code>class MyDeserializer implements Deserializer&lt;MyObject&gt; {
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public Class&lt;MyObject&gt; handledType() {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return MyObject.class;
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public String[] mediaType() {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return new String[]{&quot;*/xml&quot;};
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public MyObject deserialize(String response, DeserializationContext context) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int stringFieldStart = response.indexOf(&quot;&lt;stringField&gt;&quot;) + 13;
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int stringFieldEnd = response.indexOf(&quot;&lt;/stringField&gt;&quot;, stringFieldStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;String stringField = response.substring(stringFieldStart, stringFieldEnd);
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int intFieldStart = response.indexOf(&quot;&lt;intField&gt;&quot;, stringFieldEnd) + 10;
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int intFieldEnd = response.indexOf(&quot;&lt;/intField&gt;&quot;, intFieldStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int intField = Integer.parseInt(response.substring(intFieldStart, intFieldEnd));
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int dateFieldStart = response.indexOf(&quot;&lt;dateField&gt;&quot;, intFieldEnd) + 11;
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int dateFieldEnd = response.indexOf(&quot;&lt;/dateField&gt;&quot;, dateFieldStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;Date dateField = new Date(Long.parseLong(response.substring(dateFieldStart, dateFieldEnd)));
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return new MyObject(stringField, intField, dateField);
            <br/>&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;@Override
            <br/>&#32;&#32;&#32;&#32;public &lt;C extends Collection&lt;MyObject&gt;&gt; C deserialize(Class&lt;C&gt; collectionType, String response, DeserializationContext ctx) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;C collection = ctx.getInstance(collectionType);
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int nextStart = response.indexOf(&quot;&lt;my&gt;&quot;);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;while (nextStart != -1) {
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;int nextEnd = response.indexOf(&quot;&lt;/my&gt;&quot;, nextStart);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;collection.add(deserialize(response.substring(nextStart + 4, nextEnd), ctx));
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;nextStart = response.indexOf(&quot;&lt;my&gt;&quot;, nextEnd);
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;}
            <br/>
            <br/>&#32;&#32;&#32;&#32;&#32;&#32;&#32;&#32;return collection;
            <br/>&#32;&#32;&#32;&#32;}
            <br/>}
          </code>
        </pre>
      </div>

      <p>
        Make your deserializer available to Requestor by registering it.
      </p>

      <div class="highlight">
        <pre ui:field="myDeserializerReg" class="java">
          <code>requestor.addDeserializer(new MyDeserializer());</code>
        </pre>
      </div>

      <p>
        <em>Note: #addDeserializer returns a HandlerRegistration instance which enables you to later cancel the registration.</em>
      </p>
    </div>

    <div class="requestor-showcase-innersection">
      <h3>Serdes</h3>
      <p>
        The <code>Serdes</code> interface joins Serializer and Deserializer into one.
        Implement it if you want to provide both serialization and deserialization for some type.
      </p>

      <p>
        Make your serdes available to Requestor by registering it.
      </p>

      <div class="highlight">
        <pre ui:field="mySerdesReg" class="java">
          <code>requestor.addSerdes(new MySerdes());</code>
        </pre>
      </div>

      <p>
        <em>Note: #addSerdes returns a HandlerRegistration instance which enables you to later cancel the registration.</em>
      </p>
    </div>
  </g:HTMLPanel>

  </g:HTMLPanel>
</ui:UiBinder>